use rand::RngExt;

/// Samples from a Gamma(α, 1) distribution.
///
/// This function implements:
/// - The **Marsaglia–Tsang method** for `α ≥ 1`
/// - A standard transformation for `α < 1`:
///
/// ```text
/// Gamma(α) = Gamma(α + 1) * U^(1/α),  where U ~ Uniform(0, 1)
/// ```
///
/// This produces unbiased Gamma-distributed samples for all
/// positive `α`, including the small values (e.g. `α = 0.3`)
/// required by AlphaZero-style Dirichlet noise.
///
/// # Arguments
/// * `alpha` - Shape parameter `α > 0`
///
/// # Returns
/// A single sample drawn from `Gamma(α, 1)`
///
/// # References
/// - Marsaglia & Tsang, *A Simple Method for Generating Gamma Variables* (2000)
fn sample_gamma(alpha: f32) -> f32 {
    let mut rng = rand::rng();

    if alpha < 1.0 {
        // Use transformation: Gamma(a) = Gamma(a+1) * U^(1/a)
        let u: f32 = rng.random();
        return sample_gamma(alpha + 1.0) * u.powf(1.0 / alpha);
    }

    // Marsaglia–Tsang method for alpha >= 1
    let d = alpha - 1.0 / 3.0;
    let c = (1.0 / 3.0) / d.sqrt();

    loop {
        // Standard normal via Box–Muller
        let u1: f32 = rng.random();
        let u2: f32 = rng.random();
        let z = (-2.0 * u1.ln()).sqrt() * (2.0 * std::f32::consts::PI * u2).cos();

        let v = 1.0 + c * z;
        if v <= 0.0 {
            continue;
        }

        let v3 = v * v * v;
        let u: f32 = rng.random();

        if u < 1.0 - 0.0331 * z * z * z * z {
            return d * v3;
        }

        if u.ln() < 0.5 * z * z + d * (1.0 - v3 + v3.ln()) {
            return d * v3;
        }
    }
}

/// Samples from a symmetric Dirichlet distribution `Dirichlet(α)`.
///
/// Each component is generated by drawing an independent
/// `Gamma(α, 1)` sample and normalising the resulting vector
/// so that all entries sum to 1.
///
/// This implementation is mathematically exact and suitable
/// for AlphaZero-style exploration noise.
///
/// # Arguments
/// * `alpha` - Dirichlet concentration parameter (`α > 0`)
/// * `n` - Number of dimensions (i.e. number of actions)
///
/// # Returns
/// A probability vector of length `n` whose entries sum to 1
pub(crate) fn dirichlet(alpha: f32, n: usize) -> Vec<f32> {
    let mut samples = Vec::with_capacity(n);
    let mut sum = 0.0;

    for _ in 0..n {
        let x = sample_gamma(alpha);
        samples.push(x);
        sum += x;
    }

    for x in &mut samples {
        *x /= sum;
    }

    samples
}
